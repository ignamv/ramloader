
main.axf:     file format elf32-littlearm
main.axf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000002a5

Program Header:
    LOAD off    0x00008000 vaddr 0x00000000 paddr 0x00000000 align 2**15
         filesz 0x00000370 memsz 0x00000370 flags r-x
    LOAD off    0x00010000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000410 flags rw-
private flags = 5000202: [Version5 EABI] [soft-float ABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000370  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000410  20000000  20000000  00010000  2**2
                  ALLOC
  2 .debug_info   0000022f  00000000  00000000  00008370  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_abbrev 000001b9  00000000  00000000  0000859f  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000068  00000000  00000000  00008758  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_ranges 00000038  00000000  00000000  000087c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000000d9  00000000  00000000  000087f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    000001c3  00000000  00000000  000088d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .comment      00000033  00000000  00000000  00008a94  2**0
                  CONTENTS, READONLY
  9 .ARM.attributes 00000037  00000000  00000000  00008ac7  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000078  00000000  00000000  00008b00  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000098  00000000  00000000  00008b78  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
20000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    df *ABS*	00000000 startup.c
20000000 l     O .bss	00000400 stack
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 program.c
00000370 g       .text	00000000 _etext
000002e4 g     F .text	0000008c myprogram
00000274 g     F .text	00000030 missingISR
20000400 g     O .bss	00000010 active
20000400 g       .bss	00000000 _ebss
20000000 g       .bss	00000000 _bss
000002e4 g       .text	00000000 _program
00000268 g     F .text	0000000a main
00000000 g     O .text	00000268 vectortable
20000000 g       .text	00000000 _data
20000000 g       .text	00000000 _edata
000002a4 g     F .text	00000040 resetISR



Disassembly of section .text:

00000000 <vectortable>:
   0:	00 10 00 20 a5 02 00 00 75 02 00 00 75 02 00 00     ... ....u...u...
  10:	75 02 00 00 75 02 00 00 75 02 00 00 00 00 00 00     u...u...u.......
	...
  2c:	75 02 00 00 75 02 00 00 00 00 00 00 75 02 00 00     u...u.......u...
  3c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  4c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  5c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  6c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  7c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  8c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  9c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  ac:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  bc:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  cc:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  dc:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  ec:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
  fc:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 10c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 11c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 12c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 13c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 14c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 15c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 16c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 17c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 18c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 19c:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 1ac:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 1bc:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 1cc:	75 02 00 00 75 02 00 00 75 02 00 00 75 02 00 00     u...u...u...u...
 1dc:	75 02 00 00 75 02 00 00 75 02 00 00 00 00 00 00     u...u...u.......
	...

00000268 <main>:
// Jump to a program stored in RAM

extern void _program();

int main(void)
{
 268:	b508      	push	{r3, lr}
    _program();
 26a:	f000 f83b 	bl	2e4 <myprogram>
    return 0;
}
 26e:	2000      	movs	r0, #0
 270:	bd08      	pop	{r3, pc}
	...

00000274 <missingISR>:
void missingISR() {
    // TODO: use ACTIVE0..ACTIVE3 to indicate the interrupt source
    volatile unsigned long *activeRegs;
    activeRegs = (unsigned long*)NVIC_ACTIVE0;
    for(int i=0; i<4; i++)
        active[i] = activeRegs[i];
 274:	4b06      	ldr	r3, [pc, #24]	; (290 <missingISR+0x1c>)
 276:	681a      	ldr	r2, [r3, #0]
 278:	4b06      	ldr	r3, [pc, #24]	; (294 <missingISR+0x20>)
 27a:	601a      	str	r2, [r3, #0]
 27c:	4a06      	ldr	r2, [pc, #24]	; (298 <missingISR+0x24>)
 27e:	6812      	ldr	r2, [r2, #0]
 280:	605a      	str	r2, [r3, #4]
 282:	4a06      	ldr	r2, [pc, #24]	; (29c <missingISR+0x28>)
 284:	6812      	ldr	r2, [r2, #0]
 286:	609a      	str	r2, [r3, #8]
 288:	4a05      	ldr	r2, [pc, #20]	; (2a0 <missingISR+0x2c>)
 28a:	6812      	ldr	r2, [r2, #0]
 28c:	60da      	str	r2, [r3, #12]
 28e:	e7fe      	b.n	28e <missingISR+0x1a>
 290:	e000e300 	.word	0xe000e300
 294:	20000400 	.word	0x20000400
 298:	e000e304 	.word	0xe000e304
 29c:	e000e308 	.word	0xe000e308
 2a0:	e000e30c 	.word	0xe000e30c

000002a4 <resetISR>:
    // An axplanation of the tasks resetISR must carry out is available in
    // http://www.embecosm.com/appnotes/ean9/html/ch05s02.html
    // .data is the section for initialized variables
    // Copy the initial values from Flash to SRAM
    unsigned long *src=&_etext, *dest=&_data;
    while(dest < &_edata)
 2a4:	2300      	movs	r3, #0
 2a6:	4a0a      	ldr	r2, [pc, #40]	; (2d0 <resetISR+0x2c>)
 2a8:	490a      	ldr	r1, [pc, #40]	; (2d4 <resetISR+0x30>)
 2aa:	1898      	adds	r0, r3, r2
 2ac:	4288      	cmp	r0, r1
 2ae:	d204      	bcs.n	2ba <resetISR+0x16>
        *dest++ = *src++;
 2b0:	4909      	ldr	r1, [pc, #36]	; (2d8 <resetISR+0x34>)
 2b2:	5859      	ldr	r1, [r3, r1]
 2b4:	5099      	str	r1, [r3, r2]
 2b6:	3304      	adds	r3, #4
 2b8:	e7f5      	b.n	2a6 <resetISR+0x2>
    // An axplanation of the tasks resetISR must carry out is available in
    // http://www.embecosm.com/appnotes/ean9/html/ch05s02.html
    // .data is the section for initialized variables
    // Copy the initial values from Flash to SRAM
    unsigned long *src=&_etext, *dest=&_data;
    while(dest < &_edata)
 2ba:	4b08      	ldr	r3, [pc, #32]	; (2dc <resetISR+0x38>)
        *dest++ = *src++;
    // .bss is the section for zero-initialized variables
    dest=&_bss;
    while(dest < &_ebss)
 2bc:	4a08      	ldr	r2, [pc, #32]	; (2e0 <resetISR+0x3c>)
 2be:	4293      	cmp	r3, r2
 2c0:	d203      	bcs.n	2ca <resetISR+0x26>
        *dest++ = 0;
 2c2:	2200      	movs	r2, #0
 2c4:	f843 2b04 	str.w	r2, [r3], #4
 2c8:	e7f8      	b.n	2bc <resetISR+0x18>

    main();
 2ca:	f7ff bfcd 	b.w	268 <main>
 2ce:	bf00      	nop
 2d0:	20000000 	.word	0x20000000
 2d4:	20000000 	.word	0x20000000
 2d8:	00000370 	.word	0x00000370
 2dc:	20000000 	.word	0x20000000
 2e0:	20000400 	.word	0x20000400

000002e4 <myprogram>:
#include "../../ek-lm4f120xl.h"

__attribute__((section(".program")))
int myprogram(void) {
    // Enable UART0 clock
    SYSCTL_RCGCUART_R |= SYSCTL_RCGCUART_R0;
 2e4:	4b1e      	ldr	r3, [pc, #120]	; (360 <myprogram+0x7c>)
 2e6:	681a      	ldr	r2, [r3, #0]
 2e8:	f042 0201 	orr.w	r2, r2, #1
 2ec:	601a      	str	r2, [r3, #0]
    // Enable GPIOA clock
    SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R0;
 2ee:	f853 2c10 	ldr.w	r2, [r3, #-16]
 2f2:	f042 0201 	orr.w	r2, r2, #1
 2f6:	f843 2c10 	str.w	r2, [r3, #-16]
    // GPIOA0 = RX, GPIOA1 = TX
    GPIO_PORTA_AFSEL_R |= UARTPORT_RX | UARTPORT_TX;
 2fa:	f5a3 237a 	sub.w	r3, r3, #1024000	; 0xfa000
 2fe:	f5a3 73fc 	sub.w	r3, r3, #504	; 0x1f8
    GPIO_PORTA_DEN_R |= UARTPORT_RX | UARTPORT_TX;
    // Falta PCTL, DIR
    // Set baud rate generation for 115200 baud from 16MHz clock
    UART0_CTL_R &= ~UART_CTL_UARTEN;
    UART0_IBRD_R = 8;
 302:	2108      	movs	r1, #8
    // Enable UART0 clock
    SYSCTL_RCGCUART_R |= SYSCTL_RCGCUART_R0;
    // Enable GPIOA clock
    SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R0;
    // GPIOA0 = RX, GPIOA1 = TX
    GPIO_PORTA_AFSEL_R |= UARTPORT_RX | UARTPORT_TX;
 304:	681a      	ldr	r2, [r3, #0]
 306:	f042 0203 	orr.w	r2, r2, #3
 30a:	601a      	str	r2, [r3, #0]
    GPIO_PORTA_DEN_R |= UARTPORT_RX | UARTPORT_TX;
 30c:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
 310:	f042 0203 	orr.w	r2, r2, #3
 314:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    // Falta PCTL, DIR
    // Set baud rate generation for 115200 baud from 16MHz clock
    UART0_CTL_R &= ~UART_CTL_UARTEN;
 318:	f503 43f8 	add.w	r3, r3, #31744	; 0x7c00
 31c:	3310      	adds	r3, #16
 31e:	681a      	ldr	r2, [r3, #0]
 320:	f022 0201 	bic.w	r2, r2, #1
 324:	601a      	str	r2, [r3, #0]
    UART0_IBRD_R = 8;
 326:	4a0f      	ldr	r2, [pc, #60]	; (364 <myprogram+0x80>)
 328:	6011      	str	r1, [r2, #0]
    UART0_FBRD_R = 44;
 32a:	212c      	movs	r1, #44	; 0x2c
 32c:	6051      	str	r1, [r2, #4]
    // 8N1, enable FIFOs
    UART0_LCRH_R = UART_LCRH_WLEN_8 | UART_LCRH_FEN;
 32e:	2170      	movs	r1, #112	; 0x70
 330:	6091      	str	r1, [r2, #8]
    UART0_CC_R |= UART_CC_CS_PIOSC;
 332:	f8d2 1fa4 	ldr.w	r1, [r2, #4004]	; 0xfa4
 336:	f041 0105 	orr.w	r1, r1, #5
 33a:	f8c2 1fa4 	str.w	r1, [r2, #4004]	; 0xfa4
    UART0_CTL_R |= UART_CTL_RXE | UART_CTL_TXE;
 33e:	681a      	ldr	r2, [r3, #0]
 340:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 344:	601a      	str	r2, [r3, #0]
    UART0_CTL_R |= UART_CTL_UARTEN;
 346:	681a      	ldr	r2, [r3, #0]
 348:	f042 0201 	orr.w	r2, r2, #1
 34c:	601a      	str	r2, [r3, #0]
    // Echo received characters
    while(1) {
        while(UART0_FR_R & UART_FR_RXFE);
 34e:	4b06      	ldr	r3, [pc, #24]	; (368 <myprogram+0x84>)
 350:	681b      	ldr	r3, [r3, #0]
 352:	06db      	lsls	r3, r3, #27
 354:	d4fb      	bmi.n	34e <myprogram+0x6a>
        char c = UART0_DR_R;
 356:	4b05      	ldr	r3, [pc, #20]	; (36c <myprogram+0x88>)
 358:	681a      	ldr	r2, [r3, #0]
        UART0_DR_R = c;
 35a:	b2d2      	uxtb	r2, r2
 35c:	e7f6      	b.n	34c <myprogram+0x68>
 35e:	bf00      	nop
 360:	400fe618 	.word	0x400fe618
 364:	4000c024 	.word	0x4000c024
 368:	4000c018 	.word	0x4000c018
 36c:	4000c000 	.word	0x4000c000
